### RSA简介

1977年，麻省理工学院三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字的首字母命名，叫做RSA算法。 直到现在(2019年)，RSA算法依然是应用范围最广的非对称加密算法，乃至于整个计算机界，我认为RSA现在应该是最重要的算法之一了。

这种算法非常可靠，密钥越长，它就越难破解（本质上是对大数的质因数分解很难）。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。

### 数学概念

RSA加密算法中，需要用到以下几个概念，这里先整理出来：

**素数**

素数又称质数，指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。 如：2，3，5，7，11，13...

**互素**

维基百科上的解释是：互质，又称互素。若N个整数的最大公因子是1，则称这N个整数互质。

常见的互质数判断方法有几种，其中一种我们后面会用到： *较大数是质数的两个数是互质数(*这个概念后面会用到*)。如23与20。

**欧拉函数**

> 欧拉函数 φ(n)是小于或等于n的正整数中与n互质的数的数目 *如果n = 1, φ(1) = 1；(小于等于1的正整数中唯一和1互质的数就是1本身)；* 如果n为质数，φ(n) = n - 1；因为质数和每一个比它小的数字都互质。比如5，比它小的正整数1,2,3,4都和他互质； * 若m,n互质，则φ(mn) = φ(m)φ(n)

**模运算**

模运算即求余运算。“模”是“Mod”的音译。和模运算紧密相关的一个概念是“同余”。数学上，当两个整数除以同一个正整数，若得相同余数，则二整数同余。

两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b (mod m)；读作：a同余于b模m，或者，a与b关于模m同余。例如：26 ≡ 14 (mod 12)。

**模逆元（模反元素）**

一整数a对同余n之模逆元是指满足以下公式的整数b

> ab ≡ 1 (mod n)

整数 a 对模数 n 之模逆元存在的充分必要条件是 a 和 n 互素。

**欧拉定理**

如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：

> a^φ(n) ≡ 1(mod n)

根据这个定理以及模逆元的概念，可得：a的φ(n)-1次方肯定是a关于n的模反元素。

所以a关于n的模反元素必然存在。 比如，3和5互质，而5的欧拉函数φ(5)等于4，所以3的4次方*(81)减去1，可以被5整除（80/5=16）。

## 算法过程

**公钥与密钥的产生**

假设Alice想要通过一个不可靠的媒体接收Bob的一条私人讯息。她可以用以下的方式来产生一个公钥和一个私钥：

1. 获取N: 随意选择两个大的质数p和q，p不等于q，计算N=pq
2. 获取r: 根据欧拉函数r = φ(N) = φ(p)φ(q) = (p-1)(q-1)；
3. 选择一个小于 r 的整数 e，求得 e 关于模 r 的模反元素，命名为d。（模反元素存在，当且仅当e与r互质，即求 e^(φ(r)-1) ）

(N,e)是公钥，(N,d)是私钥。Alice将她的公钥(N,e)传给Bob，私钥(N,d)自己保存。

**加密消息**

假设Bob想给Alice送一个消息message，他知道Alice产生的公钥（N，e）。 于是Bob先将message转换为一个小于N的整数m。（如果是字符串可以取ascii值或unicode值；假如信息非常长，可以将分为几段，然后将每一段转换为m） 用下面这个公式他可以将m加密为c：

> m^e ≡ c (mod N)

Bob算出c后就可以将它传递给Alice。

**解密消息**

Alice得到Bob的消息c后就可以利用她的密钥（N, d）来解码。她可以用以下这个公式来将c转换为m：

> c^d ≡ m (mod N)

得到m后，她就可以将原来的信息message重新复原。

## python程序实现

定义求模拟元的算法函数：

```
import itertools

def findModReverse(e, r):
    # 这里直接用模逆元定义的概念，for循环找出b
    # 也可以用扩展欧几里得算法或者欧拉定理计算出来
    for b in itertools.count(1):
        if (e * b) % r == 1:
            return b
```

定义求公私钥的算法函数：

```
def getNewKey(p, q, e=3):
    # e的定义是比r小和r互质的的正整数
    # 【注意】: 这里取3是方便计算演示，一般使用65537
    N = p * q
    r = (p - 1) * (q - 1)
    d = findModReverse(e, r)
    return N, e, d
```

定义加解密的算法函数：

```
def rsa(N, key, message):
    # 加密和解密本质上都是求指数和模的过程，所以可用参数不同的同一个函数
    # 这也是为什么公私钥可以互换，但是不建议（原因是公钥出于种种原因一般都很短）
    me = message ** key
    return me % N
```

通过两个小的质因数演示加解密过程获取公私钥：

```
# 取两个质数
p = 17
q = 23

# 获取公私钥
(N, e, d) = getNewKey(p, q)

print('公钥为：（%d, %d)' % (N, e))
print('私钥为：（%d, %d)' % (N, d))
```

以上输出： `公钥为：（391,3)` `私钥为：（391,235)`

加解密：

```
message = 66

# 加密
c = rsa(N, e, message)

# 解密
m = rsa(N, d, c)

print('原始消息：%d' % message)
print('加密后的值：%d' % c)
print('解密后的值：%d' % m)
```

以上输出： `原始消息：66` `加密后的值：111` `解密后的值：66`

### 后记

过程已经演示好了，我们也基本了解了RSA整个加解密过程，最后，我们简单看一下这个RSA的安全性和前景。

**安全性**

即使是在用户已经获取到公钥(N, e)的情况下，需要解开密文需要哪些步骤：

- 如果想知道 d 需要知道欧拉函数 φ(n)的结果(即上文中提到的r = φ(N))
- 如果想知道欧拉函数 φ(n) 需要知道 p 和 q
- 要知道 p 和 q 需要对 N 进行质因数分解。

对于本例中的 391 你可以轻松进行因数分解，但对于大数的质因数分解，是一件很困难的事情，目前除了暴力破解，还没有更好的办法，如果以目前的计算速度，破解需要50年以上，则这个算法就是安全的。 维基百科这样描述：

> "对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。 　 假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。 　 只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。"

目前已经破解的最大整数：

1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413 =

33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489 * 36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917

即（232个十进制位，768个二进制位），目前被破解的最长RSA密钥就是768位。实际应用中 RSA 的密钥长度为 1024 位，重要场合 2048 位，破解难度在目前这阶段基本不可能。

**缺点和未来通讯加密方式**

但是并不意味着未来RSA不能被轻松的破解掉，现如今基于量子位元（qubits,也称昆比特）的量子计算机正在如火如荼的发展，它主要应用了量子叠加态的特性，让未来的算力可能比如今传统电脑快上亿倍，那么RSA算法以及其他的加密算法都将不再安全。

而且RSA本身产生密钥很麻烦，会受到素数产生技术的限制；然后分组长度太大，为保证安全性，n 至少也要 600 bits 以上，使运算代价很高，运算速度较慢，因而难以做到一次一密。

而在将来基于量子密钥分发的量子通信会随着技术的发展应用领域逐渐变广（据了解：目前实际应用的量子密钥分发技术还是主要围绕量子不可测量特性展开，很少使用量子纠缠态特性）。

所以这里大胆做一个预测，在不久的将来(十年内)RSA会不再成为可信任的加密算法；坐等时间的验证或者打脸……O(∩_∩)O

**参考资料：**

1. [http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html](https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)
2. [https://zh.wikipedia.org/wiki/RSA加密演算法](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/RSA%25E5%258A%25A0%25E5%25AF%2586%25E6%25BC%2594%25E7%25AE%2597%25E6%25B3%2595)
3. [https://zh.wikipedia.org/wiki/模反元素](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%25A8%25A1%25E5%258F%258D%25E5%2585%2583%25E7%25B4%25A0)
4. [https://zh.wikipedia.org/wiki/欧拉定理_(数论)](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%25AC%25A7%25E6%258B%2589%25E5%25AE%259A%25E7%2590%2586_%2528%25E6%2595%25B0%25E8%25AE%25BA%2529)